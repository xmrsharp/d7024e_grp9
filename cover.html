
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">D7024E_GRP9/kademlia/bucket.go (15.8%)</option>
				
				<option value="file1">D7024E_GRP9/kademlia/cli.go (0.0%)</option>
				
				<option value="file2">D7024E_GRP9/kademlia/commands.go (0.0%)</option>
				
				<option value="file3">D7024E_GRP9/kademlia/contact.go (6.2%)</option>
				
				<option value="file4">D7024E_GRP9/kademlia/datastore.go (100.0%)</option>
				
				<option value="file5">D7024E_GRP9/kademlia/kademlia.go (8.3%)</option>
				
				<option value="file6">D7024E_GRP9/kademlia/kademliaid.go (29.2%)</option>
				
				<option value="file7">D7024E_GRP9/kademlia/message.go (0.0%)</option>
				
				<option value="file8">D7024E_GRP9/kademlia/network.go (5.1%)</option>
				
				<option value="file9">D7024E_GRP9/kademlia/request_register.go (3.4%)</option>
				
				<option value="file10">D7024E_GRP9/kademlia/result.go (0.0%)</option>
				
				<option value="file11">D7024E_GRP9/kademlia/routingtable.go (17.2%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package kademlia

import (
        "container/list"
)

// bucket definition
// contains a List
type bucket struct {
        list *list.List
}

// newBucket returns a new instance of a bucket
func newBucket() *bucket <span class="cov8" title="1">{
        bucket := &amp;bucket{}
        bucket.list = list.New()
        return bucket
}</span>

// AddContact adds the Contact to the front of the bucket
// or moves it to the front of the bucket if it already existed
func (bucket *bucket) AddContact(contact Contact) <span class="cov0" title="0">{
        var element *list.Element
        for e := bucket.list.Front(); e != nil; e = e.Next() </span><span class="cov0" title="0">{
                nodeID := e.Value.(Contact).ID

                if (contact).ID.Equals(nodeID) </span><span class="cov0" title="0">{
                        element = e
                }</span>
        }

        <span class="cov0" title="0">if element == nil </span><span class="cov0" title="0">{
                if bucket.list.Len() &lt; BucketSize </span><span class="cov0" title="0">{
                        bucket.list.PushFront(contact)
                }</span>
        } else<span class="cov0" title="0"> {
                bucket.list.MoveToFront(element)
        }</span>
}

// GetContactAndCalcDistance returns an array of Contacts where
// the distance has already been calculated
func (bucket *bucket) GetContactAndCalcDistance(target *KademliaID) []Contact <span class="cov0" title="0">{
        var contacts []Contact

        for elt := bucket.list.Front(); elt != nil; elt = elt.Next() </span><span class="cov0" title="0">{
                contact := elt.Value.(Contact)
                contact.CalcDistance(target)
                contacts = append(contacts, contact)
        }</span>

        <span class="cov0" title="0">return contacts</span>
}

// Len return the size of the bucket
func (bucket *bucket) Len() int <span class="cov0" title="0">{
        return bucket.list.Len()
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package kademlia

import (
        "bufio"
        "fmt"
        "io"
        "os"
        "strings"
)

var in *os.File = os.Stdin
var out io.Writer = os.Stdout

func Cli(output io.Writer, node *Kademlia) <span class="cov0" title="0">{
        fmt.Print("&gt;&gt;")
        reader := bufio.NewReader(in)
        for </span><span class="cov0" title="0">{
                input, _ := reader.ReadString('\n')
                parseInput := strings.TrimSpace(input)

                if parseInput == "" </span><span class="cov0" title="0">{
                        go Cli(output, node)
                        return
                }</span> else<span class="cov0" title="0"> {
                        commands := strings.Fields(parseInput)
                        Commands(output, node, commands)
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package kademlia

import (
        "fmt"
        "io"
        "os"
)

func Commands(output io.Writer, node *Kademlia, commands []string) <span class="cov0" title="0">{
        switch commands[0] </span>{
        case "put":<span class="cov0" title="0">
                if len(commands) == 2 </span><span class="cov0" title="0">{
                        Put(node, commands[1])
                }</span> else<span class="cov0" title="0"> {
                        fmt.Println("Arg error")
                }</span>
        case "get":<span class="cov0" title="0">
                if len(commands) == 2 </span><span class="cov0" title="0">{
                        Get(node, commands[1])
                }</span> else<span class="cov0" title="0"> {
                        fmt.Println("Arg error")
                }</span>
        case "exit":<span class="cov0" title="0">
                os.Exit(0)</span>
        default:<span class="cov0" title="0">
                fmt.Println(output, "invalid command")</span>
        }
}

func Put(node *Kademlia, input string) <span class="cov0" title="0">{
        res := node.StoreValue(input)
        if res.IsError() </span><span class="cov0" title="0">{
                fmt.Printf(("FAIL STORE VALUE [%s]"), input)
        }</span> else<span class="cov0" title="0"> {
                fmt.Printf("VALUE STORED\n\tVALUE:[%s]\n\tKEY:[%s]", input, res.ID.String())
        }</span>
}
func Get(node *Kademlia, value string) <span class="cov0" title="0">{
        key := NewKademliaID(&amp;value)
        res := node.LookupData(key)
        if res.IsError() </span><span class="cov0" title="0">{
                fmt.Printf(("DID NOT FIND VALUE [%s]."), value)
        }</span> else<span class="cov0" title="0"> {
                fmt.Printf(("FOUND VALUE\n\tNODE:[%s]\n\tKEY:[%s]\n\tVALUE:[%s]\n"), res.ID.String(), key.String(), res.Value)
        }</span>

}
</pre>
		
		<pre class="file" id="file3" style="display: none">package kademlia

import (
        "fmt"
        "sort"
)

// Contact definition
// stores the KademliaID, the ip address and the distance
// Change to net.UDPAddres instead of address string?
type Contact struct {
        ID       *KademliaID
        Address  string
        distance *KademliaID
}

// NewContact returns a new instance of a Contact
func NewContact(id *KademliaID, address string) Contact <span class="cov8" title="1">{
        return Contact{id, address, nil}
}</span>

// CalcDistance calculates the distance to the target and
// fills the contacts distance field
func (contact *Contact) CalcDistance(target *KademliaID) <span class="cov0" title="0">{
        contact.distance = contact.ID.CalcDistance(target)
}</span>

// Less returns true if contact.distance &lt; otherContact.distance
func (contact *Contact) Less(otherContact *Contact) bool <span class="cov0" title="0">{
        return contact.distance.Less(otherContact.distance)
}</span>

// String returns a simple string representation of a Contact
func (contact *Contact) String() string <span class="cov0" title="0">{
        return fmt.Sprintf(`contact("%s", "%s")`, contact.ID, contact.Address)
}</span>

// ContactCandidates definition
// stores an array of Contacts
type ContactCandidates struct {
        contacts []Contact
}

// Append an array of Contacts to the ContactCandidates
func (candidates *ContactCandidates) Append(contacts []Contact) <span class="cov0" title="0">{
        candidates.contacts = append(candidates.contacts, contacts...)
}</span>

// GetContacts returns the first count number of Contacts
func (candidates *ContactCandidates) GetContacts(count int) []Contact <span class="cov0" title="0">{
        return candidates.contacts[:count]
}</span>

// GetClosest returns closest contact to set target.
func (candidates *ContactCandidates) GetClosest() Contact <span class="cov0" title="0">{
        candidates.Sort()
        return candidates.contacts[0]
}</span>

// PopContact pops closest contact to set target.
func (candidates *ContactCandidates) PopClosest() Contact <span class="cov0" title="0">{
        candidates.Sort()
        temp := candidates.contacts[0]
        candidates.contacts = candidates.contacts[1:]
        return temp
}</span>

// Sort the Contacts in ContactCandidates
func (candidates *ContactCandidates) Sort() <span class="cov0" title="0">{
        sort.Sort(candidates)
}</span>

// Len returns the length of the ContactCandidates
func (candidates *ContactCandidates) Len() int <span class="cov0" title="0">{
        return len(candidates.contacts)
}</span>

// Swap the position of the Contacts at i and j
// WARNING does not check if either i or j is within range
func (candidates *ContactCandidates) Swap(i, j int) <span class="cov0" title="0">{
        candidates.contacts[i], candidates.contacts[j] = candidates.contacts[j], candidates.contacts[i]
}</span>

// Less returns true if the Contact at index i is smaller than
// the Contact at index j
func (candidates *ContactCandidates) Less(i, j int) bool <span class="cov0" title="0">{
        return candidates.contacts[i].Less(&amp;candidates.contacts[j])
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package kademlia

import (
        "fmt"
        "log"
)

type KademliaMap = map[KademliaID]string

type DataStore struct {
        data KademliaMap
}

func NewDataStore() DataStore <span class="cov8" title="1">{
        return DataStore{make(KademliaMap)}
}</span>

func (data *DataStore) Insert(key KademliaID, val string) <span class="cov8" title="1">{
        data.data[key] = val
}</span>

func (data *DataStore) KeyExist(key KademliaID) bool <span class="cov8" title="1">{
        _, ok := data.data[key]
        return ok
}</span>

func (data *DataStore) Get(key KademliaID) string <span class="cov8" title="1">{
        if val, ok := data.data[key]; ok </span><span class="cov8" title="1">{
                log.Printf("GET in DATASTORE found VAL: %s", string(val))
                return val
        }</span> else<span class="cov8" title="1"> {
                return ""
        }</span>
}

func (data *DataStore) PrintStore(test KademliaMap) <span class="cov8" title="1">{
        fmt.Println("CURRENT DATASTORE:")
        for key, value := range data.data </span><span class="cov8" title="1">{
                fmt.Printf("[%s]:[%s]", key, value)
        }</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package kademlia

import (
        "D7024E_GRP9/api"
        "errors"
        "fmt"
        "log"
        "os"
        "strconv"
        "time"
)

// TODO Address constant value missuse
const (
        ALPHA_VALUE = 3
        K_VALUE     = 20
)

// TODO Discuss about changing go version from 1.13 -&gt; 1.18
// Logic and state of Kademlia node
type Kademlia struct {
        kademliaServer     *Network
        apiServer          *api.APIServer
        outgoingRequests   *OutgoingRegister
        channelAPI         &lt;-chan api.APIChannel // api channel.
        channelServerInput &lt;-chan msg            // kad node server channel.
        channelNodeLookup  chan []Contact        // NodeLookup rpc
        channelStoreValue  chan KademliaID       // Store channel rpc
        channelValueLookup chan msg              // FindValue channel rpc
        datastore          DataStore
        routingTable       *RoutingTable
}

func NewKademlia(ip string, portKademlia int, portAPI int, id *KademliaID) *Kademlia <span class="cov8" title="1">{

        // Init shared channels
        channelServerInput := make(chan msg)
        channelNodeLookup := make(chan []Contact)
        channelStoreValue := make(chan KademliaID)
        channelValueLookup := make(chan msg)

        addrs := ip + ":" + strconv.Itoa(portKademlia)
        outgoingRequests := NewOutgoingRegister()
        selfContact := NewContact(id, addrs)
        kademliaServer := NewNetwork(selfContact, addrs, outgoingRequests, channelServerInput)
        routingTable := NewRoutingTable(selfContact)

        channelAPI := make(chan api.APIChannel)
        apiServer := api.NewServer(ip, portAPI, channelAPI)

        datastore := NewDataStore()

        kademliaNode := Kademlia{kademliaServer: kademliaServer,
                apiServer:          apiServer,
                outgoingRequests:   outgoingRequests,
                channelAPI:         channelAPI,
                channelServerInput: channelServerInput,
                channelNodeLookup:  channelNodeLookup,
                channelStoreValue:  channelStoreValue,
                channelValueLookup: channelValueLookup,
                routingTable:       routingTable,
                datastore:          datastore}
        return &amp;kademliaNode
}</span>

func (node *Kademlia) ReturnCandidates(caller *Contact, target *KademliaID) <span class="cov0" title="0">{
        candidates := node.routingTable.FindClosestContacts(target, 20)
        node.kademliaServer.respondFindContactMessage(caller, candidates)
}</span>

func (node *Kademlia) NodeLookup(target *KademliaID) <span class="cov0" title="0">{
        func(drain chan []Contact) </span><span class="cov0" title="0">{
                for </span><span class="cov0" title="0">{
                        select </span>{
                        case _ = &lt;-drain:<span class="cov0" title="0">
                                log.Println("REMOVED STALE FIND_NODE RESPONSE")</span>
                        default:<span class="cov0" title="0">
                                return</span>
                        }
                }
        }(node.channelNodeLookup)

        // Clean out any straglers from incoming requests that have not responded within a set amount of time.
        <span class="cov0" title="0">defer node.outgoingRequests.ResetRegister()
        // Initiate candidates.
        currentCandidates := ContactCandidates{node.routingTable.FindClosestContacts(target, BucketSize)}

        // Inititate end condition.
        currentClosestNode := currentCandidates.GetClosest()
        probedNoCloser := 0

        // Visited nodes
        consumedCandidates := make(map[KademliaID]int)

        // For keeping track off active outgoing FindNode RPCs.
        activeAlphaCalls := 0
        for probedNoCloser &lt; BucketSize </span><span class="cov0" title="0">{
                if currentClosestNode.ID.Equals(target) </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">for activeAlphaCalls &lt; ALPHA_VALUE &amp;&amp; currentCandidates.Len() &gt; 0 </span><span class="cov0" title="0">{
                        tempContact := currentCandidates.PopClosest()
                        // Check for alrdy consumed nodes.
                        if consumedCandidates[*tempContact.ID] == 1 || *tempContact.ID == *node.routingTable.me.ID </span><span class="cov0" title="0">{
                                // Already consumed contact - dead end.
                                activeAlphaCalls--
                        }</span> else<span class="cov0" title="0"> {
                                consumedCandidates[*tempContact.ID] += 1
                                node.kademliaServer.SendFindContactMessage(&amp;tempContact, *target)
                        }</span>
                        <span class="cov0" title="0">activeAlphaCalls++</span>
                }
                <span class="cov0" title="0">if !node.outgoingRequests.ExpectingAnyRequest() </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">select </span>{
                case newCandidates := &lt;-node.channelNodeLookup:<span class="cov0" title="0">
                        // Recieved response in allowed interval
                        for i := 0; i &lt; len(newCandidates); i++ </span><span class="cov0" title="0">{
                                newCandidates[i].CalcDistance(target)
                                node.kademliaServer.SendPingMessage(&amp;(newCandidates[i]))
                        }</span>
                        // Only need to check head of list as list is ordered on arrival.
                        <span class="cov0" title="0">if !currentClosestNode.Less(&amp;newCandidates[0]) </span><span class="cov0" title="0">{
                                // Got closer to target, update current closest and succesfull probes.
                                probedNoCloser = 0
                                currentClosestNode = newCandidates[0]
                        }</span> else<span class="cov0" title="0"> {
                                // No closer to target.
                                probedNoCloser++
                        }</span>
                        <span class="cov0" title="0">currentCandidates.Append(newCandidates)
                        activeAlphaCalls--</span>
                case &lt;-time.After(3 * time.Second):<span class="cov0" title="0">
                        log.Println("Failed to recieve FIND_NODE response within time interval")
                        return</span>
                }
        }
}

func (node *Kademlia) LookupData(key KademliaID) Result <span class="cov0" title="0">{
        val := node.datastore.Get(key)
        var response Result
        if val != "" </span><span class="cov0" title="0">{
                response.ID = *node.routingTable.me.ID
                response.Value = val
                return response // Works, meaning found value in local node.
        }</span>

        // Refresh any previously stored values in pipe.
        <span class="cov0" title="0">func() </span><span class="cov0" title="0">{
                for </span><span class="cov0" title="0">{
                        select </span>{
                        case _ = &lt;-node.channelValueLookup:<span class="cov0" title="0">
                                log.Println("STALE GET VALUE FLUSHED")</span>
                        default:<span class="cov0" title="0">
                                return</span>
                        }
                }
        }()
        <span class="cov0" title="0">node.NodeLookup(&amp;key)
        neighbours := node.routingTable.FindClosestContacts(&amp;key, BucketSize)
        for i := 0; i &lt; len(neighbours); i++ </span><span class="cov0" title="0">{
                if *neighbours[i].ID != *node.routingTable.me.ID </span><span class="cov0" title="0">{
                        node.kademliaServer.SendFindDataMessage(&amp;(neighbours[i]), key)
                }</span>
        }

        <span class="cov0" title="0">var responseAck Result
        for </span><span class="cov0" title="0">{
                select </span>{
                case valueConfirmation := &lt;-node.channelValueLookup:<span class="cov0" title="0">
                        proposedValue := valueConfirmation.Payload.FindValue.Value
                        if NewKademliaID(&amp;proposedValue) == key </span><span class="cov0" title="0">{
                                responseAck.ID = *valueConfirmation.Caller.ID
                                responseAck.Value = proposedValue
                                return responseAck
                        }</span>
                case &lt;-time.After(3 * time.Second):<span class="cov0" title="0">
                        responseAck.Err = errors.New("Failed to fetch value of key")
                        return responseAck</span>
                }
        }
}

func (node *Kademlia) StoreValue(data string) Result <span class="cov0" title="0">{
        key := NewKademliaID(&amp;data)

        // Unloading all old accepted store values from channel.
        func() </span><span class="cov0" title="0">{
                for </span><span class="cov0" title="0">{
                        select </span>{
                        case _ = &lt;-node.channelStoreValue:<span class="cov0" title="0">
                                log.Println("STALE STORE ACK FLUSHED")</span>
                        default:<span class="cov0" title="0">
                                return</span>
                        }
                }
        }()

        <span class="cov0" title="0">node.NodeLookup(&amp;key)
        storeCandidates := node.routingTable.FindClosestContacts(&amp;key, K_VALUE)
        // NOTE 2 For testing purposes
        //for i := 0; i &lt; len(storeCandidates); i++ {
        for i := 0; i &lt; 2; i++ </span><span class="cov0" title="0">{
                if *storeCandidates[i].ID != *node.routingTable.me.ID </span><span class="cov0" title="0">{
                        node.kademliaServer.SendStoreMessage(&amp;(storeCandidates[i]), key, data)
                }</span>
        }

        <span class="cov0" title="0">var responseAck Result
        for </span><span class="cov0" title="0">{
                select </span>{
                case keyConfirmation := &lt;-node.channelStoreValue:<span class="cov0" title="0">
                        if keyConfirmation == key </span><span class="cov0" title="0">{
                                responseAck.ID = key
                                return responseAck
                        }</span>
                case &lt;-time.After(3 * time.Second):<span class="cov0" title="0">
                        responseAck.Err = errors.New("Failed to ack store value.")
                        return responseAck</span>
                }
        }

}

func (node *Kademlia) bootLoader(bootLoaderAddrs string, bootLoaderID KademliaID) <span class="cov0" title="0">{
        if bootLoaderAddrs == "" </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">bootContact := NewContact(&amp;bootLoaderID, bootLoaderAddrs)
        node.routingTable.AddContact(bootContact)
        node.NodeLookup(node.routingTable.me.ID)</span>
}

func (node *Kademlia) handleIncomingRPC(kademliaServerMsg msg) <span class="cov0" title="0">{
        if kademliaServerMsg.Method != 0 </span><span class="cov0" title="0">{

                log.Printf(("[%s] RECIEVED [%s] EVENT FROM [%s]:[%s]"), node.routingTable.me.Address, kademliaServerMsg.Method.String(), kademliaServerMsg.Caller.Address, kademliaServerMsg.Caller.ID)
                if kademliaServerMsg.Caller.Address == node.routingTable.me.Address </span><span class="cov0" title="0">{
                        log.Printf("SUSPECT CALLER [%s] REASON: IDENTICAL ADDRS AS SERVER", kademliaServerMsg.Caller.ID)
                        return
                }</span>
        }

        // Adding caller of any incoming request.
        <span class="cov0" title="0">node.routingTable.AddContact(kademliaServerMsg.Caller)
        switch kademliaServerMsg.Method </span>{
        case Ping:<span class="cov0" title="0">
                if kademliaServerMsg.Payload.PingPong == "PING" </span><span class="cov0" title="0">{
                        node.kademliaServer.respondPingMessage(&amp;kademliaServerMsg.Caller)
                }</span>
        case FindNode:<span class="cov0" title="0">
                go func() </span><span class="cov0" title="0">{
                        // TODO Need to check that register is correctly incremented/decremented.
                        if kademliaServerMsg.Payload.Candidates == nil </span><span class="cov0" title="0">{
                                node.ReturnCandidates(&amp;kademliaServerMsg.Caller, &amp;kademliaServerMsg.Payload.FindNode)
                        }</span> else<span class="cov0" title="0"> {
                                if node.outgoingRequests.ExpectingRequest(*kademliaServerMsg.Caller.ID) </span><span class="cov0" title="0">{
                                        node.channelNodeLookup &lt;- kademliaServerMsg.Payload.Candidates
                                }</span> else<span class="cov0" title="0"> {
                                        log.Printf("SUSPECT CALLER [%s] REASON: UNEXPECTED FIND_NODE RESPONSE", kademliaServerMsg.Caller.ID)
                                }</span>
                        }
                }()
        case FindValue:<span class="cov0" title="0">
                go func() </span><span class="cov0" title="0">{
                        if kademliaServerMsg.Payload.FindValue.Value == "" </span><span class="cov0" title="0">{
                                // Call to search for value in own datastore
                                val := node.datastore.Get(kademliaServerMsg.Payload.FindValue.Key)
                                if val != "" </span><span class="cov0" title="0">{
                                        node.kademliaServer.respondFindDataMessage(&amp;kademliaServerMsg.Caller, val)
                                }</span>
                        } else<span class="cov0" title="0"> {
                                // Response from other node of value.
                                node.channelValueLookup &lt;- kademliaServerMsg
                        }</span>
                }()
        case Store:<span class="cov0" title="0">
                go func() </span><span class="cov0" title="0">{
                        if kademliaServerMsg.Payload.Store.Value == "" </span><span class="cov0" title="0">{
                                node.channelStoreValue &lt;- kademliaServerMsg.Payload.Store.Key
                                return
                        }</span>
                        <span class="cov0" title="0">key := kademliaServerMsg.Payload.Store.Key
                        value := kademliaServerMsg.Payload.Store.Value
                        node.datastore.Insert(key, value)
                        if node.datastore.KeyExist(key) </span><span class="cov0" title="0">{
                                node.kademliaServer.respondStoreMessage(&amp;kademliaServerMsg.Caller, key)
                        }</span>
                }()

        default:<span class="cov0" title="0">
                log.Println("PANIC - UNKNOWN RPC METHOD")</span>
        }
}

func (node *Kademlia) handleIncomingAPIRequest(apiRequest api.APIChannel) <span class="cov0" title="0">{
        var res *Result
        switch apiRequest.ApiRequestMethod </span>{
        case "GET_VALUE":<span class="cov0" title="0">
                key := apiRequest.ApiRequestPayload
                var id KademliaID
                for i := 0; i &lt; 20; i++ </span><span class="cov0" title="0">{
                        id[i] = key[i]
                }</span>
                <span class="cov0" title="0">log.Println("LOOKING UP KEY: ", id)
                *res = node.LookupData(id)
                log.Println("GET_VALUE: RECIEVED:", *res)
                log.Println("INSERT CALL HERE TO GET VALUE FROM KEY:", key, " AND RETURN THE VALUE")</span>
        case "STORE_VALUE":<span class="cov0" title="0">
                valueToStore := apiRequest.ApiRequestPayload
                *res = node.StoreValue(string(valueToStore))
                log.Println("STORE_VALUE RECIEVED::", *res)</span>
        default:<span class="cov0" title="0">
                log.Panic("RECIEVED INVALID API REQUEST METHOD FROM HTTP SERVER", apiRequest)</span>

        }
        <span class="cov0" title="0">go func(res Result, method string, resp chan []byte) </span><span class="cov0" title="0">{
                log.Println("AND RES IN GO ROUTINE IS :", res)
                if res.IsError() </span><span class="cov0" title="0">{
                        log.Println("ERROR:", method)
                        log.Println(res)
                        resp &lt;- []byte("ERROR")
                        return
                }</span>
                <span class="cov0" title="0">resp &lt;- []byte(res.ID.String() + " - " + res.Value)</span>
        }(*res, apiRequest.ApiRequestMethod, apiRequest.ApiResponseChannel)
}

func (node *Kademlia) Run(bootLoaderAddrs string, bootLoaderID KademliaID) <span class="cov0" title="0">{
        go node.kademliaServer.Listen()
        go node.apiServer.Listen()
        go func() </span><span class="cov0" title="0">{
                // TODO Quick fix for bootloader.
                time.Sleep(time.Second)
                node.bootLoader(bootLoaderAddrs, bootLoaderID)
        }</span>()
        <span class="cov0" title="0">go Cli(os.Stdout, node)
        for </span><span class="cov0" title="0">{
                select </span>{
                case apiRequest := &lt;-node.channelAPI:<span class="cov0" title="0">
                        node.handleIncomingAPIRequest(apiRequest)</span>
                case kademliaServerMsg := &lt;-node.channelServerInput:<span class="cov0" title="0">
                        node.handleIncomingRPC(kademliaServerMsg)</span>
                }
        }
}

// NOTE ONLY TO BE USED FOR TESTING/DEMONSTRATION PURPOSES ONLY
func (node *Kademlia) genCheckBuckets() <span class="cov0" title="0">{
        count := 0
        for i := 0; i &lt; 20; i++ </span><span class="cov0" title="0">{
                //num_entries := node.routingTable.buckets[i].Len()
                // fmt.Println("BUCKET:", i, " Contains ", num_entries, " number of entries.")
                for j := node.routingTable.buckets[i].list.Front(); j != nil; j = j.Next() </span><span class="cov0" title="0">{
                        // NOTE If individual number of entries are to be inspected.
                        //fmt.Println("V:", j.Value)
                        count++
                }</span>
        }
        <span class="cov0" title="0">fmt.Println("TOTAL NUMBER OF UNIQUE ENTRIES : ", count)</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package kademlia

import (
        "crypto/sha1"
        "encoding/hex"
        "time"
)

// the static number of bytes in a KademliaID
const IDLength = 20

// type definition of a KademliaID
type KademliaID [IDLength]byte

// NewKademliaID returns a new instance of a KademliaID based on the string input
func NewKademliaIDString(data string) *KademliaID <span class="cov8" title="1">{
        decoded, _ := hex.DecodeString(data)

        newKademliaID := KademliaID{}
        for i := 0; i &lt; IDLength; i++ </span><span class="cov8" title="1">{
                newKademliaID[i] = decoded[i]
        }</span>

        <span class="cov8" title="1">return &amp;newKademliaID</span>
}

func NewKademliaID(data *string) KademliaID <span class="cov8" title="1">{
        newKademliaID := sha1.Sum([]byte(*data))
        return newKademliaID
}</span>

func NewRandomKademliaID() *KademliaID <span class="cov0" title="0">{
        newKademliaID := KademliaID{}
        for i := 0; i &lt; IDLength; i++ </span><span class="cov0" title="0">{
                newKademliaID[i] = byte((time.Now().Nanosecond()) % 256)
        }</span>
        <span class="cov0" title="0">return &amp;newKademliaID</span>
}

// Less returns true if kademliaID &lt; otherKademliaID (bitwise)
func (kademliaID KademliaID) Less(otherKademliaID *KademliaID) bool <span class="cov0" title="0">{
        for i := 0; i &lt; IDLength; i++ </span><span class="cov0" title="0">{
                if kademliaID[i] != otherKademliaID[i] </span><span class="cov0" title="0">{
                        return kademliaID[i] &lt; otherKademliaID[i]
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

// Equals returns true if kademliaID == otherKademliaID (bitwise)
func (kademliaID KademliaID) Equals(otherKademliaID *KademliaID) bool <span class="cov0" title="0">{
        for i := 0; i &lt; IDLength; i++ </span><span class="cov0" title="0">{
                if kademliaID[i] != otherKademliaID[i] </span><span class="cov0" title="0">{
                        return false
                }</span>
        }
        <span class="cov0" title="0">return true</span>
}

// CalcDistance returns a new instance of a KademliaID that is built
// through a bitwise XOR operation betweeen kademliaID and target
func (kademliaID KademliaID) CalcDistance(target *KademliaID) *KademliaID <span class="cov0" title="0">{
        result := KademliaID{}
        for i := 0; i &lt; IDLength; i++ </span><span class="cov0" title="0">{
                result[i] = kademliaID[i] ^ target[i]
        }</span>
        <span class="cov0" title="0">return &amp;result</span>
}

// String returns a simple string representation of a KademliaID
func (kademliaID *KademliaID) String() string <span class="cov0" title="0">{
        return hex.EncodeToString(kademliaID[0:IDLength])
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">package kademlia

import (
        "bytes"
        "encoding/gob"
        "log"
)

type msg struct {
        Method  RPCMethod
        Caller  Contact // Will need an address of where to respond to as each instance is only keeping an open port.
        Payload content
}

type content struct {
        PingPong   string     // Simply calling it for face value, ping pong.
        FindValue  Tuple      // To be used for find value.
        Key        KademliaID // FindValue: key. Ok why use both values here?? TODO REPLACE KEY VALUE with FindValue Tuple instead.
        Value      string     // FindValue: value.
        Store      Tuple      // Store: Key, Value
        Candidates []Contact  // Store/FindNode/FindValue candidates if not found.
        FindNode   KademliaID // FindNode: Target
}

type Tuple struct {
        Key   KademliaID
        Value string
}

type RPCMethod int

func (r RPCMethod) String() string <span class="cov0" title="0">{
        switch r </span>{
        case 0:<span class="cov0" title="0">
                return "PING"</span>
        case 1:<span class="cov0" title="0">
                return "STORE"</span>
        case 2:<span class="cov0" title="0">
                return "FIND_NODE"</span>
        case 3:<span class="cov0" title="0">
                return "FIND_VALUE"</span>
        default:<span class="cov0" title="0">
                return "UNKNOWN"</span>
        }

}

const (
        Ping RPCMethod = iota
        Store
        FindNode
        FindValue
)

func encodeMsg(m msg) ([]byte, error) <span class="cov0" title="0">{
        var buf bytes.Buffer
        enc := gob.NewEncoder(&amp;buf)
        err := enc.Encode(m)
        if err != nil </span><span class="cov0" title="0">{
                //log.Printf(("COULD NOT ENCODE MSG: [%s] - %s"), m, err)
                return nil, nil
        }</span>
        <span class="cov0" title="0">msg_buf := make([]byte, 2048)
        n, _ := buf.Read(msg_buf)
        return msg_buf[:n], nil</span>
}

func decodeMsg(inp []byte) (m msg, e error) <span class="cov0" title="0">{
        buf := bytes.NewBuffer(inp)
        dec := gob.NewDecoder(buf)
        var inc msg
        err := dec.Decode(&amp;inc)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf(("COULD NOT DECODE MSG: [%s] - %s"), inp, err)
                return inc, err
        }</span>
        <span class="cov0" title="0">return inc, nil</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package kademlia

import (
        "log"
        "net"
)

type Network struct {
        msgHeader        Contact
        outgoingRequests *OutgoingRegister
        addrs            *net.UDPAddr
        channelWriteNode chan&lt;- msg
}

func NewNetwork(msgHeader Contact, addrs string, outgoingRequests *OutgoingRegister, write chan&lt;- msg) *Network <span class="cov8" title="1">{
        udpAddr, err := net.ResolveUDPAddr("udp", addrs)
        if err != nil </span><span class="cov0" title="0">{
                log.Panicf(("CANNOT SERVE ON SPEC ADDR - %s"), err)
        }</span>
        <span class="cov8" title="1">network := Network{msgHeader, outgoingRequests, udpAddr, write}

        return &amp;network</span>
}

func (network *Network) Listen() <span class="cov0" title="0">{
        serverSocket, err := net.ListenUDP("udp", network.addrs)
        if err != nil </span><span class="cov0" title="0">{
                log.Println(err)
        }</span>
        <span class="cov0" title="0">log.Println("KAD NODE SERVING ON:", network.addrs)
        defer serverSocket.Close()
        for </span><span class="cov0" title="0">{
                // Change size of reader.
                buff := make([]byte, 16384)
                n, caller_addr, err := serverSocket.ReadFromUDP(buff)
                if err != nil </span><span class="cov0" title="0">{
                        log.Println("FAILED TO READ SOCKET:", err)
                }</span> else<span class="cov0" title="0"> {
                        go network.handleRequest(buff[:n], caller_addr)
                }</span>
        }
}

func (network *Network) handleRequest(m []byte, addr *net.UDPAddr) <span class="cov0" title="0">{
        decodedMsg, err := decodeMsg(m)
        if err != nil </span><span class="cov0" title="0">{
                log.Println("UNKNOWN MSG BY:", addr)
                return
        }</span>
        <span class="cov0" title="0">network.channelWriteNode &lt;- decodedMsg</span>
}

func (network *Network) sendRequest(m msg, to Contact) <span class="cov0" title="0">{
        if m.Method != 0 </span><span class="cov0" title="0">{
                log.Printf(("[%s] SENDING [%s] TO: [%s]"), network.addrs, m.Method, to.Address)
        }</span>
        <span class="cov0" title="0">payload, err := encodeMsg(m)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf(("ENCODING ERROR: %s"), err)
        }</span>
        <span class="cov0" title="0">udpAddr, err := net.ResolveUDPAddr("udp", to.Address)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf(("RESOLVE ADDR ERR TO [%s] - %s"), to.Address, err)
        }</span>
        <span class="cov0" title="0">conn, err := net.DialUDP("udp", nil, udpAddr)
        defer conn.Close()
        if err != nil </span><span class="cov0" title="0">{
                log.Printf(("FAILED TO ESTABLISH SOCKET TO [%s] - %s"), to.Address, err)
        }</span>
        <span class="cov0" title="0">_, err = conn.Write(payload)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf(("FAILED TO WRITE - %s"), err)
        }</span>
}

func (network *Network) respondPingMessage(to *Contact) <span class="cov0" title="0">{
        m := new(msg)
        m.Method = Ping
        m.Caller = network.msgHeader
        m.Payload.PingPong = "PONG"
        network.sendRequest(*m, *to)
}</span>
func (network *Network) SendPingMessage(to *Contact) <span class="cov0" title="0">{
        m := new(msg)
        m.Method = Ping
        m.Caller = network.msgHeader
        m.Payload.PingPong = "PING"
        network.sendRequest(*m, *to)
}</span>

func (network *Network) respondFindContactMessage(to *Contact, candidates []Contact) <span class="cov0" title="0">{
        m := new(msg)
        m.Method = FindNode
        m.Caller = network.msgHeader
        m.Payload.Candidates = candidates
        network.sendRequest(*m, *to)
}</span>
func (network *Network) SendFindContactMessage(to *Contact, target KademliaID) <span class="cov0" title="0">{
        m := new(msg)
        m.Method = FindNode
        m.Caller = network.msgHeader
        m.Payload.FindNode = target
        network.outgoingRequests.RegisterOutgoing(*to.ID)
        network.sendRequest(*m, *to)
}</span>

func (network *Network) respondFindDataMessage(to *Contact, data string) <span class="cov0" title="0">{
        m := new(msg)
        m.Method = FindValue
        m.Caller = network.msgHeader
        m.Payload.FindValue.Value = data
        network.sendRequest(*m, *to)
}</span>

func (network *Network) SendFindDataMessage(to *Contact, key KademliaID) <span class="cov0" title="0">{
        m := new(msg)
        m.Method = FindValue
        m.Caller = network.msgHeader
        m.Payload.FindValue.Key = key
        network.sendRequest(*m, *to)
}</span>

func (network *Network) respondStoreMessage(to *Contact, key KademliaID) <span class="cov0" title="0">{
        m := new(msg)
        m.Method = Store
        m.Caller = network.msgHeader
        m.Payload.Store.Key = key
        network.sendRequest(*m, *to)
}</span>

func (network *Network) SendStoreMessage(to *Contact, target KademliaID, data string) <span class="cov0" title="0">{
        m := new(msg)
        m.Method = Store
        m.Caller = network.msgHeader
        m.Payload.Store.Key = target
        m.Payload.Store.Value = data
        network.sendRequest(*m, *to)
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">package kademlia

import (
        "log"
        "sync"
)

// OutgoingRegister used by Kademlia and network to synchronize expected incoming responses by other nodes.
type OutgoingRegister struct {
        mutex    *sync.Mutex
        register map[KademliaID]int
}

func NewOutgoingRegister() *OutgoingRegister <span class="cov8" title="1">{
        return &amp;OutgoingRegister{&amp;sync.Mutex{}, make(map[KademliaID]int)}
}</span>

func (reg *OutgoingRegister) RegisterOutgoing(target KademliaID) <span class="cov0" title="0">{
        reg.mutex.Lock()
        defer reg.mutex.Unlock()
        reg.register[target] += 1
}</span>

func (reg *OutgoingRegister) ResetRegister() <span class="cov0" title="0">{
        reg.mutex.Lock()
        defer reg.mutex.Unlock()
        reg.register = make(map[KademliaID]int)

}</span>

func (reg *OutgoingRegister) PrintRegister() <span class="cov0" title="0">{
        reg.mutex.Lock()
        defer reg.mutex.Unlock()
        for key, num := range reg.register </span><span class="cov0" title="0">{
                if num &gt; 0 </span><span class="cov0" title="0">{
                        log.Println("CURRENTLY EXCEPTING RESPONSE FROM", key.String(), " - num responses:", num)
                }</span>
        }

}

func (reg *OutgoingRegister) RegisterIncoming(target KademliaID) <span class="cov0" title="0">{
        reg.mutex.Lock()
        defer reg.mutex.Unlock()
        if reg.register[target] &lt; 1 </span><span class="cov0" title="0">{
                log.Println("PANIC - PROCESSED REQUEST FROM UNKNOWN.")
        }</span>
        <span class="cov0" title="0">reg.register[target] -= 1</span>

}

func (reg *OutgoingRegister) ExpectingRequest(target KademliaID) bool <span class="cov0" title="0">{
        reg.mutex.Lock()
        defer reg.mutex.Unlock()
        if reg.register[target] &gt; 0 </span><span class="cov0" title="0">{
                reg.register[target] -= 1
                return true
        }</span>
        <span class="cov0" title="0">return false</span>

}

func (reg *OutgoingRegister) ExpectingAnyRequest() bool <span class="cov0" title="0">{
        reg.mutex.Lock()
        defer reg.mutex.Unlock()
        for _, v := range reg.register </span><span class="cov0" title="0">{
                if v &gt; 0 </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>

}
</pre>
		
		<pre class="file" id="file10" style="display: none">package kademlia

type Result struct {
        ID    KademliaID // Treated as node id and key digest.
        Value string
        Err   error
}

func (r *Result) IsError() bool <span class="cov0" title="0">{
        return r.Err != nil
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">package kademlia

const BucketSize = 20

// RoutingTable definition
// keeps a refrence contact of me and an array of buckets
type RoutingTable struct {
        me      Contact
        buckets [IDLength * 8]*bucket
}

// NewRoutingTable returns a new instance of a RoutingTable
func NewRoutingTable(me Contact) *RoutingTable <span class="cov8" title="1">{
        routingTable := &amp;RoutingTable{}
        for i := 0; i &lt; IDLength*8; i++ </span><span class="cov8" title="1">{
                routingTable.buckets[i] = newBucket()
        }</span>
        <span class="cov8" title="1">routingTable.me = me
        return routingTable</span>
}

// AddContact add a new contact to the correct Bucket
func (routingTable *RoutingTable) AddContact(contact Contact) <span class="cov0" title="0">{
        bucketIndex := routingTable.getBucketIndex(contact.ID)
        bucket := routingTable.buckets[bucketIndex]
        bucket.AddContact(contact)
}</span>

// FindClosestContacts finds the count closest Contacts to the target in the RoutingTable
func (routingTable *RoutingTable) FindClosestContacts(target *KademliaID, count int) []Contact <span class="cov0" title="0">{
        var candidates ContactCandidates
        bucketIndex := routingTable.getBucketIndex(target)
        bucket := routingTable.buckets[bucketIndex]

        candidates.Append(bucket.GetContactAndCalcDistance(target))

        for i := 1; (bucketIndex-i &gt;= 0 || bucketIndex+i &lt; IDLength*8) &amp;&amp; candidates.Len() &lt; count; i++ </span><span class="cov0" title="0">{
                if bucketIndex-i &gt;= 0 </span><span class="cov0" title="0">{
                        bucket = routingTable.buckets[bucketIndex-i]
                        candidates.Append(bucket.GetContactAndCalcDistance(target))
                }</span>
                <span class="cov0" title="0">if bucketIndex+i &lt; IDLength*8 </span><span class="cov0" title="0">{
                        bucket = routingTable.buckets[bucketIndex+i]
                        candidates.Append(bucket.GetContactAndCalcDistance(target))
                }</span>
        }

        <span class="cov0" title="0">candidates.Sort()

        if count &gt; candidates.Len() </span><span class="cov0" title="0">{
                count = candidates.Len()
        }</span>

        <span class="cov0" title="0">return candidates.GetContacts(count)</span>
}

// getBucketIndex get the correct Bucket index for the KademliaID
func (routingTable *RoutingTable) getBucketIndex(id *KademliaID) int <span class="cov0" title="0">{
        distance := id.CalcDistance(routingTable.me.ID)
        for i := 0; i &lt; IDLength; i++ </span><span class="cov0" title="0">{
                for j := 0; j &lt; 8; j++ </span><span class="cov0" title="0">{
                        if (distance[i]&gt;&gt;uint8(7-j))&amp;0x1 != 0 </span><span class="cov0" title="0">{
                                return i*8 + j
                        }</span>
                }
        }

        <span class="cov0" title="0">return IDLength*8 - 1</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
